----
title: Haskell for group theorists
tags: haskell
mathjax: on
----

I'm no expert on either group theory or Haskell, but this is my writeup on
how one can carry over some of the ideas they already know about group theory
into practical programming knowledge in Haskell.

## Groups and monoids in mathematics

A monoid is a more general structure than a group. A **group** is a set
and a binary operation that has some fairly strict axioms. If we have a
group $G$ with an operation $\cdot$, then the following must hold:

* *Closure*: for all $a$, $b$ in $G$, $a \cdot b$ is in $G$.
* *Associativity*: for all $a$, $b$ in a $G$,
  $(a \cdot b) \cdot c = a \cdot (b \cdot c)$.
* *Identity*: There exists an element $e$ in $G$ such that for every element
  $a$ in $G$, $a \cdot e = a$.
* *Invertibility*: For every element  $a$ in $G$, there exists an
  inverse element $a^{-1}$ for $a$ such that $a \cdot a^{-1}$ is the identity
  element.

A (mathematical) **monoid** is a set together with a binary operation
with only closure, associativity, and identity requirements.
Thus a monoid is a group where the operator is not necessarily
invertible, and all groups are monoids which also have invertibility.

## Monoids in Haskell

In Haskell we have a builtin typeclass for monoids:

````{.haskell}
class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
    mconcat :: [m] -> m
    mconcat = foldr mappend mempty
````

This means that in order to make a monoid for a type **m** (essentially,
a set $\mathbb{m}$)[^sets] in Haskell, we need to define two things:

- `mempty`, the identity element
- `mappend`, the binary function

Note that mconcat is defined in the typeclass itself. These two
functions must obey the same laws as mathematical monoids, and if they
do, then the rest will be enforced by the compiler.

### Identity

Combining `mempty` with any `x` in **m** must always yield `x`.

````{.haskell}
mempty `mappend` x = x
x `mappend` mempty = x
````

This property is one of the
[monoid laws](https://en.wikibooks.org/wiki/Haskell/Monoids#Haskell_definition_and_laws)
in Haskell, meaning it is enforced by the author of the monoid in particular,
not by the compiler.
However, functions that expect a `monoid` as input will assume that
the identity property holds.

If we wanted to represent the monoid corresponding to the cyclic group
$$C_n= \langle a\, |\, a^n = 1\rangle,$$
we could write

````{.haskell}
data Cn = A

instance Monoid Cn where
  mempty = A
  A `mappend` A = A
````

and it is clear from the definition that the monoid `Cn` has identity.
At any rate, it is usually trivial to write monoids that conform to this
law, since both cases can be defined explicitly in the monoid definition.

### Associativity

The result of the binary operation is the same, independent of
parenthesization.

````{.haskell}
(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
````

This is another of the monoid laws, so we must be careful to ensure
that any monoids we write conform to it.

### Closure

Closure is enforced by the type signatures provided by the
typeclass for monoids; We see that all operations are closed under the
typeclass **m** in the typeclass definition: `mempty`, `mappend`, and
`mconcat` all have a domain in **m** and a range in **m**.

#### mempty
`mempty` is the identity element, so it is in **m**.

#### mappend
`mappend` is a function $f$ such that $f(x, y) = z$, where $x$, $y$,
and $z$ are in $\mathbb{m}$. This is by definition how the type signature
`mappend :: m -> m -> m` is read,
though
[currying](https://en.wikipedia.org/wiki/Currying)
means this can also be seen as function $f$ that is something like
$f(x) = \big(g(y) = z\big)$.
In other words, we can partially apply $f$ to give us a new function $g(y) = z$,
instead of supplying both parameters at one time.

Writing these as anonymous functions gives us a proper way to
represent currying in mathematics.
In the case of `mappend`, we could write
$(x, y) \mapsto z$
for the original function and
$x \mapsto (y \mapsto z)$
for its curried equivalent.

#### mconcat
For `mconcat` the property of closure is not immediately obvious, since
`mconcat` operates on a list of elements in **m** instead of just one
element in **m**. To show that Haskell's monoids are still closed within
**m**, we need to know the type signature for foldr:

````{.haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b.
````
First we define the sets
$$\mathbb{a} :\equiv \textbf{a},\\
\mathbb{b} :\equiv \textbf{b}$$
to complete our analogy between Haskell and math.
We can read this as follows: `foldr` is a function $f$ such that

$$ f\big(h(x, y),\, j,\, \mathbb{k}\big) = t, $$

where $\mathbb{k}$ is a subset of $\mathbb{a}$, and $j$, $t$ are in $\mathbb{b}$, and $h$ is a
function of the form

$$ h(x, y) = z, $$

where $x$ is in $\mathbb{a}$ and $y$, $z$ are in $\mathbb{b}$. 
Since `mappend` is a binary function of the form $h(x, y) = z$ where $x$, $y$,
$z$ are in $\mathbb{m}$, and `mempty` is in **m**, in the instance of `mconcat` we can
treat `foldr` as having the type signature

````{.haskell}
foldr :: ((m -> (m -> m)) -> m) -> ([m] -> m)
````

which, when applied to `mappend`, becomes

````{.haskell}
(foldr mappend) :: m -> ([m] -> m)
````

and then, applying this to `mempty`,

````{.haskell}
(foldr mappend mempty) :: [m] -> m
````

Note that this is the same type signature as

```{.haskell}
mconcat :: [m] -> m
```

Since Haskell's monoid typeclass is associative by law and one may
prove that
[associativity implies generalized associativity](http://groupprops.subwiki.org/wiki/Associative_implies_generalized_associative),
`mconcat` can be defined by default in the typeclass and follows directly
from Haskell's monoid laws, and the monoid will still remain closed under
**m**.

## Why do monoids matter?

A number of types in Haskell fall under the typeclass `Monoid`.
Besides the mathematical examples, one such type that is interesting to
programmers is `String`:

```{.haskell}
λ import Data.Monoid
λ "abc" `mappend` "def"
"abcdef"
λ mempty :: String
""
λ mconcat ["a", "b", "c", "d", "e", "f"]
"abcdef"
λ mempty `mappend` "abc"
"abc"
λ "abc" `mappend` mempty
"abc"
```

Using the type `Int` for example, if we chose our operation to be
`(+)`, then we do not get an instance monoid for `Int` where our operation
is `(*)`, etc. But we can do it:[^mappend]

```{.haskell}
import Data.Monoid

instance Monoid Int where
    mempty = 0
    mappend = (+)
```

```{.haskell}
λ let x = 10 :: Int
λ let y = 20 :: Int
λ x <> y
30
λ x <> mempty
10
λ mempty <> x
10
```
### From monoids to groups
Looking at this, we might think it would be useful to write our own typeclass
for `Group`. Luckily for us, there's already one out there! The
[`groups`](http://hackage.haskell.org/package/groups-0.4.0.0)
package provides a typeclass for groups that we can use.

It defines groups like this:
```{.haskell}
class Monoid m => Group m where
    invert :: m -> m
```
So we see: something has to be a Monoid to be a Group, and we have to define
the function `invert` to make it into a group. Armed with this knowledge, we
can make our `Int` Monoid into a tried-and-true Group:

```{.haskell}
instance Group Int where
    invert x = (-x)
```

```{.haskell}
λ let x = 3 :: Int
λ let y = 5 :: Int
λ x <> (invert x)
0
λ x <> (invert y) <> y
3
```

Of course, even with this definition, we still have the same problem
that we encountered when creating monoids out of `Int`: we can only
do it for one operation. The `Data.Monoid` package provides an elegant
solution to this: it defines a type for `Sum`, then provides a way
of making any `Num` into a `Sum` monoid.[^sum]

```{.haskell}
newtype Sum a = Sum { getSum :: a }
    deriving (Eq, Ord, Read, Show, Bounded)

instance Num a => Monoid (Sum a) where
    mempty = Sum 0
    Sum x `mappend` Sum y = Sum (x + y)
```
We can use it as follows:
```{.haskell}
λ let x = Sum 10
λ let y = Sum 20
λ x <> y
Sum {getSum = 30}
```
The library likewise provides definitions for a product of `Num`s,
as well as conjunction and disjunction for booleans.

```{.haskell}
λ (Product 5) <> (Product 3)
Product {getProduct = 15}
λ (Any True) <> (Any False)
Any {getAny = True}
λ (Any True) <> (Any True)
Any {getAny = True}
λ (All True) <> (All False)
All {getAll = False}
λ (All True) <> (All True)
All {getAll = True}
```

### Using QuickCheck to verify assertions

For simple verification, where we do not need a formal proof, we can
use [QuickCheck](http://hackage.haskell.org/package/QuickCheck-2.6)
to verify our assertions.

For example, to verify that addition over the integers is an Abelian
group,[^Integer]

```{.haskell}
import Test.QuickCheck
import Test.QuickCheck.Property

testableSum :: Integer -> Integer -> Bool
testableSum a b = (Sum a) <> (Sum b) == (Sum b) <> (Sum a)
```

This test is pretty obviously true, and QuickCheck agrees.

```{.haskell}
λ quickCheck testableSum
+++ OK, passed 100 tests.
```

This next one should be false.

```{.haskell}
testableSum' :: Int -> Int -> Bool
testableSum' a b = (Sum a) <> (Sum b) == (Sum b) <> (Sum a) <> (Sum 1)
```

```{.haskell}
λ quickCheck testableSum'
*** Failed! Falsifiable (after 1 test and 1 shrink):
0
0
```

[^sets]: In this article, I use blackboard font
(e.g. $\mathbb{Z}$)
to denote a
mathematical set, **boldface** to denote the underlying set behind a
Haskell type, and `monospace` to denote a Haskell type. In many
cases, the way we reason about the three can be equivalent, and it is
common to abuse the notation and conflate them.
[^mappend]: Note that the function `(<>)` is an alias for `mappend`
that is an infix operator instead of prefix, i.e. we can do
```{.haskell}
"abc" <> "def"
```
without enclosing the symbol in backticks (\`) to make it infix.
[^sum]: Here's a
[link](http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Monoid.html#Sum)
to the source code for `Sum`.
[^Integer]: The `Integer` type allows for infinite precision integers,
while `Int` does not, so for our verification purposes we are using
`Integer` here.
